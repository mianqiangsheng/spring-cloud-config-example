# DynamicDataSourceAutoConfiguration-动态数据源核心自动配置类

1、通过DynamicDataSourceProperties来加载配置文件中的相关信息
2、控制该配置类优先于原生的spring的DataSource配置类DataSourceAutoConfiguration和druid配置类DruidDataSourceAutoConfigure进行加载
3、同时引入其他配置类DruidDynamicDataSourceConfiguration（类原生DruidDataSourceAutoConfigure），DynamicDataSourceCreatorAutoConfiguration（创建针对各种连接池实现的创造器DataSourceCreator），DynamicDataSourceHealthCheckConfiguration（如果配置了spring.datasource.dynamic.health且有spring-boot-starter-actuator依赖，则额外提供通过actuator实现的检查DataSource健康状况的能力）
4、创建多数据源加载接口DynamicDataSourceProvider，这里默认只有YmlDynamicDataSourceProvider，即从yml信息中加载所有数据源 你可以自己实现从其他地方加载所有数据源。

5、创建核心动态数据源组件DynamicRoutingDataSource，其实现InitializingBean接口，所以在bean实例化时会调用afterPropertiesSet()方法，调用DynamicDataSourceProvider的loadDataSources()方法从DynamicDataSourceProperties读取配置的数据源信息，使用之前创建的创造器DataSourceCreator创建对应的DataSource（根据@Order指定指定的顺序，默认Jndi、Druid、Hikari、Beecp、DBCP2），并统一包装成ItemDataSource按照Map<String, DataSource>结构存放各个数据源。这些数据源按照自定义的分组规则额外也存放到一个Map中。有个细节就是放入重复的DataSource时会自动调用原来的DataSource的close方法，用新的DataSource替换掉。
6、创建处理@DS注解的切面DynamicDataSourceAnnotationAdvisor，达到动态切换数据源的目的。
7、创建处理@DSTransactional注解的切面。



# 自动切换数据源原理（@DS注解如何被拦截处理的）
1、DynamicDataSourceAnnotationAdvisor切面，spring会自动应用该切面定义的切点Pointcut定位哪些bean需要加入切面的Advice增强逻辑形成代理类，在执行@DS注解的类或方法时，自动实现数据源的切换。
2、作为Advice的DynamicDataSourceAnnotationInterceptor，其主要功能包括应用动态参数解析器DsProcessor（如果数据源名以“#”开头，则通过它来确定真正的数据源）来解析数据源；应用DataSourceClassResolver来根据切点的类和方法以及@DS注解指定的数据源找到该处应该使用什么数据源来执行数据库操作，并将该信息存入缓存，其后DynamicDataSourceAnnotationInterceptor将获取的数据源名压入栈DynamicDataSourceContextHolder，至于为何使用栈？是因为实现多个service互相调用时能按后进先出的顺序依次获取对应的数据源新型数据库操作。其中DataSourceClassResolver.computeDatasource()按照1.当前方法 2.桥接方法 3.当前类开始一直找到Object顺序查找类和方法对应的数据源。


# DynamicRoutingDataSource如何实现切换数据源
1、在DynamicDataSourceAnnotationInterceptor执行增强逻辑找到对应的数据源且放入DynamicDataSourceContextHolder后，DynamicRoutingDataSource运行切面代理类的真正操作数据库方法，从DynamicDataSourceContextHolder的线程栈中推出数据源名并从一开始启动缓存的dataSourceMap中获取DataDource对象，执行获取数据库连接DataSource.getConnection()。
大致调用逻辑如下：
DataServiceImpl.selectFromLizhen() ->
JdbcTemplate.queryForList() ->
(DynamicRoutingDataSource)AbstractRoutingDataSource.getConnection() ->
DynamicRoutingDataSource.determineDataSource().getConnection()

# 集成MybatisPlus？

# 使用DynamicRoutingDataSource作为mybatis的数据源。

mybatis数据库操作涉及主要的类：基本就是类似于AOP，每个方法执行之前做逻辑的嵌入处理，根本和其他任何框架一样，dataSource.getConnection()然后执行sql语句。
MybatisMapperProxy
MybatisMapperMethod
MybatisPlusInterceptor

SqlSessionTemplate
DefaultSqlSession

mybatis配置类：获取datasource交给SqlSessionFactory，包装成mybatis的类比如SqlSessionTemplate来操作。
MybatisPlusAutoConfiguration


# 什么叫懒加载？
连接池创建出来后并不会立即初始化连接池，等需要使用connection的时候再初始化。就是创建dataSource后执行init()方法的时机是放在项目启动还是进行第一次数据库连接时。


# 均衡负载是怎么实现的？
本质上是当使用分组dataSource，即datasource_1、datasource_2、datasource_3三个数据源，当使用@DS(datasource)配合配置的均衡负载策略，从候选的3个数据源中挑选某一个来连接。


# mybatis读写分离如何实现？
提供MasterSlaveAutoRoutingPlugin这个插件，应用AOP在执行数据库操作时根据当前的SqlCommandType是否为SELECT来判断是否使用SLAVE数据源还是MASTER数据源。
